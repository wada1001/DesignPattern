# DesignPattern

https://www.oreilly.co.jp/books/9784873119762/

# 原則

変化する部分をカプセル化する  
継承よりCompositionの方が好ましい  
インターフェースに対してプログラミングする  
疎結合を使う  
拡張に対しては開き、変更に対しては閉じておく  
抽象に依存すべき  
呼び出させずに呼び出すようにする(TemplateMethodなど  
クラスが変更される理由は一つにする  



## Strategy (SimUDuck)

is a よりも has aの方が優れることがある  
オーバーライドは優れた考え方ではあるが、再利用性は低くなる  
カプセル化された振る舞いは交換可能で再利用性が高い(関数ポインタでも代用ができる)  

## Observer (WeatherApp)

変化を通知する  
不変な部分を見定めて変更が起こる部分と分離する  
追加や変更において既存の部分の変更を少なく  

## Decorator (StarBuzzCoffee)

OpenClosedの原則。全てに適用ではなく、最も変化する可能性の高い場所に目を向ける  
DecoratorはComponentの代役であるため継承する  
返却を配列で行うようにすれば順番の制御は容易い  
小さなクラスが大量にできる可能性がある  
また、構造の複雑化により生成管理が難しくなりうる  
それはFactory、Builderとの併用で軽減できる  

## Factory (PizzaStore)

Factoryに作成を追い出すことによって複数の場所でそのFactoryを使うことができる  
色々なところでnewすると変更箇所が増えていく  
Factoryをインスタンス化するかどうかは用途によって決める  
単純なものであればstaticで十分  
継承させてサブクラスで作らせることで恩恵を最大限に受けられる  
FactoryMethodは共通部分がある場合効果があるが、なければFactoryインターフェースを実装するだけでいいか？  
コーンのトッピングはアリだと思う  

## Singleton (ChocolateBoiler)

起動時にインスタンスを外から作って渡す実装を見たことがあるがあれはなんだったのだろう  
便利なことはあるが、多用はできないし複数スレで扱う時に注意が必要  

## Command (HomeAutomation)

実行をラップする。コマンドの作成時に必要なものを渡さないといけない？  
引数を取る実装を見たことがあるが、どうだろうか  
Strategyは振る舞いのカプセル化。入れ替えによる振る舞いの変更  
コマンドは格納されたオブジェクトに変更を加える  

## Adapter (DuckAdapter)
よく使ってるパターン  
異なるインターフェースの間に入り適合させる  
WebApiを実行する時に戻り値の文字のままでは使えないが、変換してどメンインぽオブジェクトで戻すようなアレ  

## Facade (SweetHomeAutomation)

Facadeは単純化、Adapterは変換が目的である  
Facadeはよく使っているはずだが意識していないし、抽象化ができていない例が多いと思った  

## TemplateMethod (StarBuzzCoffe2)

サブクラスに継承させたメソッドを決まった順番に呼ぶ  
FactoryMethod、Strategyパターンとの類似を感じた  
実際そうで継承して実装させるか、用意して入れるか程度の差しかないが、依存度や柔軟性、クラス数などで異なる  
これよりもHookという考え方の方が重要に思えた。Next.jsとかで見るアレ  
Hookは低水準Componentへの依存の仕方を整理する  


## Iterator, Composite (CorporateMerger)

CollectionはIteratorと関わり深い  
LinqのEnumerableなんかも近い  
実装詳細を明かすことなく、一つのインターフェースで同列に扱う技術  
Compositeの単一責任を犯す実装はトレードオフである  

## State, Proxy (MightyGumball)

Strategyパターンは大体同じ役割を持っていて、実装によっては代替できるが分岐が外に漏れる  
Strategyは常に一つの振る舞いに委譲するパターン  
Stateは一つに定まるが、状態と共に振る舞いを変えるパターン  
世にはさまざまな解釈、用途のStateMachineが存在して古典的なパターンを知らなかった  
Contextの立ち位置を知ることができてよかった  
今までは状態に変数を持たせたりしていたが、利便性のための少し外れた実装だと知った  
振り返ると便利「そう」だと思ってやってきたことが別の問題を産んでいた気もする  
Proxyはオブジェクトにアクセスする方法を隠蔽する  
遠方にあろうと作成で遅延する可能性があろうと問題がない  
理解度的にはインターフェース挟めば後からなんとかなるくらい...  



